#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import argparse, base64, os, shlex, sys
import winrm

def make_session(host: str, username: str, password: str,
                 port: int = 5985, ssl: bool = False,
                 auth: str = "ntlm",
                 verify_ssl: bool = False,
                 read_timeout_sec: int = 90,           # ← antes 60
                 operation_timeout_sec: int = 60):     # ← mantener < read_timeout_sec
    """
    Crea una sesión WinRM.
    """
    # Normalización por si llegan mal
    if operation_timeout_sec <= 0:
        operation_timeout_sec = 60
    if read_timeout_sec <= operation_timeout_sec:
        read_timeout_sec = operation_timeout_sec + 30

    scheme = "https" if ssl else "http"
    endpoint = f"{scheme}://{host}:{port}/wsman"
    server_cert_validation = "validate" if verify_ssl else "ignore"

    return winrm.Session(
        endpoint,
        auth=(username, password),
        transport=auth,
        server_cert_validation=server_cert_validation,
        read_timeout_sec=read_timeout_sec,
        operation_timeout_sec=operation_timeout_sec
    )

def run_ps(s: winrm.Session, ps_script: str):
    """Ejecuta PowerShell remoto y devuelve (code, stdout, stderr)."""
    r = s.run_ps(ps_script)
    out = (r.std_out or b"").decode("utf-8", errors="ignore")
    err = (r.std_err or b"").decode("utf-8", errors="ignore")
    return r.status_code, out, err

def _escape_ps_string(s: str) -> str:
    """Escapa comillas para usarlas dentro de string de PowerShell."""
    return s.replace("`", "``").replace('"', '`"')

def upload_file(s: winrm.Session, local_path: str, remote_path: str,
                chunk_size: int = 48 * 1024) -> int:
    """
    Sube un archivo al host remoto en chunks (binario seguro) usando PowerShell.
    Devuelve el total de bytes escritos o levanta excepción si falla.
    """
    if not os.path.isfile(local_path):
        raise FileNotFoundError(f"No existe el archivo local: {local_path}")

    total = 0
    first = True
    rpath = _escape_ps_string(remote_path)

    with open(local_path, "rb") as f:
        while True:
            chunk = f.read(chunk_size)
            if not chunk:
                break
            b64 = base64.b64encode(chunk).decode("ascii")
            if first:
                # Primera escritura: WriteAllBytes
                ps = (
                    f"$bytes = [Convert]::FromBase64String('{b64}');"
                    f"[IO.File]::WriteAllBytes(\"{rpath}\",$bytes)"
                )
                first = False
            else:
                # Append binario usando FileStream
                ps = (
                    f"$bytes = [Convert]::FromBase64String('{b64}');"
                    f"$fs = [IO.File]::Open(\"{rpath}\",[IO.FileMode]::Append);"
                    f"$fs.Write($bytes,0,$bytes.Length);"
                    f"$fs.Close()"
                )
            code, out, err = run_ps(s, ps)
            if code != 0:
                raise RuntimeError(f"Error al escribir chunk (code={code}). STDOUT:\n{out}\nSTDERR:\n{err}")
            total += len(chunk)

    return total

def parse_command(cstr: str):
    """
    Parse de -c. Soporta:
      upload <local_path> <remote_path>
    """
    parts = shlex.split(cstr)
    if not parts:
        raise ValueError("Comando vacío en -c")
    op = parts[0].lower()
    if op == "upload":
        if len(parts) != 3:
            raise ValueError('Uso: -c "upload <local_path> <remote_path>"')
        return ("upload", parts[1], parts[2])
    else:
        raise ValueError(f"Operación no soportada: {op}")

def probe_winrm(session) -> tuple[bool, str]:
    """
    Intenta ejecutar un comando trivial para verificar que la shell WinRM abre.
    Devuelve (ok, detalle_error_si_falla).
    """
    try:
        code, out, err = run_ps(session, 'whoami; $PSVersionTable.PSVersion.ToString()')
        if code == 0:
            return True, ""
        return False, f"Shell abrió pero devolvió código {code}. STDERR: {err.strip()}"
    except Exception as e:
        return False, str(e)

def upload_with_fallback(session, local_path: str, remote_path: str) -> int:
    """
    Intenta subir a remote_path. Si falla por 'Access is denied' en escritura,
    reintenta en %TEMP% con mismo nombre.
    Devuelve bytes escritos. Lanza excepción si todo falla.
    """
    try:
        return upload_file(session, local_path, remote_path)
    except RuntimeError as e:
        msg = str(e)
        # Bloqueo típico por Controlled Folder Access / permisos sobre Documents
        if ("Access is denied" in msg) or ("UnauthorizedAccessException" in msg):
            # Reintentar en %TEMP%
            fname = os.path.basename(remote_path)
            temp_dest = "${env:TEMP}\\" + fname  # PowerShell expandirá la variable
            print(f"[i] Acceso denegado en destino. Reintentando en TEMP como: {temp_dest}")
            return upload_file(session, local_path, temp_dest)
        raise

def main():
    p = argparse.ArgumentParser(description="Acciones simples vía WinRM (upload).")
    p.add_argument("target", help="Host/IP destino (WinRM)")
    p.add_argument("-u", "--username", default="", help="Usuario (puede ser DOMAIN\\user)")
    p.add_argument("-p", "--password", default="", help="Contraseña")
    p.add_argument("-c", "--command", required=True,
                   help='Comando. Ej: "upload /path/local C:\\\\Ruta\\\\remota"')
    p.add_argument("--port", type=int, default=5985, help="Puerto WinRM (5985 http / 5986 https)")
    p.add_argument("--ssl", action="store_true", help="Usar HTTPS (5986)")
    p.add_argument("--auth", default="ntlm", choices=["ntlm","basic","kerberos","credssp"],
                   help="Transporte WinRM (default: ntlm)")
    p.add_argument("--verify-ssl", action="store_true", help="Validar cert de servidor (solo HTTPS)")
    p.add_argument("--timeout", type=int, default=60, help="Timeout (seg)")
    args = p.parse_args()

    try:
        op, a1, a2 = parse_command(args.command)
    except Exception as e:
        print(f"[!] {e}")
        sys.exit(2)

    # Crear sesión
    try:
        # Derivar timeouts compatibles con pywinrm
        op_to  = max(1, args.timeout)          # p.ej. 60
        read_to = op_to + 30                   # p.ej. 90 (si subes archivos grandes, súbelo más)

        # Crear sesión (con tu lógica de timeouts ya parcheada)
        sess = make_session(
            host=args.target,
            username=args.username,
            password=args.password,
            port=args.port,
            ssl=args.ssl,
            auth=args.auth,
            verify_ssl=args.verify_ssl,
            read_timeout_sec=read_to,
            operation_timeout_sec=op_to
        )

        ok_probe, detail = probe_winrm(sess)
        if not ok_probe:
            # Mensaje claro para el caso AccessDenied de WSMan
            if "Access is denied" in detail or "AccessDenied" in detail:
                print("[!] WinRM AccessDenied: la cuenta no tiene permisos para PowerShell Remoting.")
                print("    - Añadir al grupo 'Administrators' o conceder acceso al endpoint de WinRM.")
                print("    - Verifica 'Enable-PSRemoting', WSMan y políticas de remoting.")
            else:
                print(f"[!] No se pudo abrir shell WinRM: {detail}")
            sys.exit(1)


    except Exception as e:
        print(f"[!] No se pudo crear sesión WinRM: {e}")
        sys.exit(1)

    if op == "upload":
        local_path, remote_path = a1, a2
        try:
            written = upload_with_fallback(sess, local_path, remote_path)
            print(f"Upload OK → {written} bytes")
        except Exception as e:
            print(f"[!] Falló upload: {e}")
            sys.exit(1)


if __name__ == "__main__":
    main()
