#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import argparse, json, re, sys, urllib.parse
from dataclasses import dataclass, asdict
from typing import Optional, Tuple

try:
    import requests
except ImportError:
    print("[!] Falta 'requests'. Instálalo con: pip install requests", file=sys.stderr)
    sys.exit(2)

# -------------------- Utilidades --------------------
UA = "Mozilla/5.0 (compatible; web-drupal-enum/1.0)"
CHANGELOG_CANDIDATES = [
    "/CHANGELOG.txt",
    "/CHANGELOG.TXT",
    "/CHANGELOG",
    "/core/CHANGELOG.txt",   # Drupal 8+
    "/core/CHANGELOG.TXT",
    "/core/CHANGELOG",
]

GEN_META_RE = re.compile(r'<meta[^>]+name=["\']generator["\'][^>]+content=["\']([^"\']+)["\']', re.I)
GEN_HEADER_RE = re.compile(r"drupal\s+([0-9][0-9.a-z-]*)", re.I)
CHANGELOG_VER_RE = re.compile(r"^\s*Drupal\s+([0-9][0-9.\-a-z]*)\b", re.I | re.M)

@dataclass
class Finding:
    url: str
    status: int
    version: Optional[str]
    source: str   # "changelog" | "x-generator" | "unknown"
    vulnerabilities: list
    notes: list

def build_base_url(target: str, https: bool, port: Optional[int]) -> str:
    # Si target ya trae esquema, respétalo.
    parsed = urllib.parse.urlparse(target if "://" in target else "")
    if parsed.scheme:
        return target.rstrip("/")
    scheme = "https" if https else "http"
    host = target.strip().strip("/")
    if port:
        return f"{scheme}://{host}:{port}"
    return f"{scheme}://{host}"

def http_get(url: str, timeout: int = 8, verify: bool = True) -> Tuple[int, str, dict]:
    r = requests.get(url, headers={"User-Agent": UA}, timeout=timeout, verify=verify, allow_redirects=True)
    text = r.text if isinstance(r.text, str) else r.content.decode("utf-8", "ignore")
    return r.status_code, text, r.headers

def normalize_version(v: str) -> str:
    # Limpia “7.54,” → “7.54”; “7.4.0-rc1” → “7.4.0”
    v = v.strip().rstrip(",")
    v = re.sub(r"[^0-9.].*$", "", v)  # corta sufijos no numéricos
    # Asegura al menos mayor.menor (Drupal 7.x y 8.x tienen 2 o 3 campos)
    return v

def ver_tuple(v: str, pad: int = 3) -> Tuple[int, ...]:
    parts = [int(p) for p in v.split(".") if p.isdigit()]
    while len(parts) < pad:
        parts.append(0)
    return tuple(parts[:pad])

def eval_vulns(version: str) -> Tuple[list, list]:
    vulns, notes = [], []
    if not version:
        return vulns, notes
    v = ver_tuple(version)

    # ---- Reglas estáticas clave ----
    # SA-CORE-2014-005 (CVE-2014-3704) – fixed 7.32
    if v[0] == 7 and v < ver_tuple("7.32"):
        vulns.append({"id": "CVE-2014-3704", "name": "SA-CORE-2014-005 SQLi", "fixed_in": "7.32"})

    # Drupalgeddon2 (CVE-2018-7600) – fixed 7.58; 8.3.9 / 8.4.6 / 8.5.1
    if v[0] == 7 and v < ver_tuple("7.58"):
        vulns.append({"id": "CVE-2018-7600", "name": "Drupalgeddon2 RCE", "fixed_in": "7.58"})
    if v[0] == 8:
        if v < ver_tuple("8.3.9"):  # 8.0–8.3.8
            vulns.append({"id": "CVE-2018-7600", "name": "Drupalgeddon2 RCE", "fixed_in": "8.3.9/8.4.6/8.5.1"})
        elif ver_tuple("8.4.0") <= v < ver_tuple("8.4.6"):
            vulns.append({"id": "CVE-2018-7600", "name": "Drupalgeddon2 RCE", "fixed_in": "8.4.6"})
        elif ver_tuple("8.5.0") <= v < ver_tuple("8.5.1"):
            vulns.append({"id": "CVE-2018-7600", "name": "Drupalgeddon2 RCE", "fixed_in": "8.5.1"})

    # CVE-2018-7602 – fixed 7.59; 8.4.8; 8.5.5
    if v[0] == 7 and v < ver_tuple("7.59"):
        vulns.append({"id": "CVE-2018-7602", "name": "Core RCE follow-up", "fixed_in": "7.59"})
    if v[0] == 8:
        if ver_tuple("8.5.0") <= v < ver_tuple("8.5.5"):
            vulns.append({"id": "CVE-2018-7602", "name": "Core RCE follow-up", "fixed_in": "8.5.5"})
        if ver_tuple("8.4.0") <= v < ver_tuple("8.4.8"):
            vulns.append({"id": "CVE-2018-7602", "name": "Core RCE follow-up", "fixed_in": "8.4.8"})

    # Nota útil: ramas EOL (ejemplo simple; no exhaustivo)
    if v[0] == 8 and v < ver_tuple("8.9.0"):
        notes.append("Drupal 8 < 8.9 es EOL; múltiples issues potenciales.")
    return vulns, notes

def extract_from_changelog(text: str) -> Optional[str]:
    m = CHANGELOG_VER_RE.search(text or "")
    if not m:
        return None
    return normalize_version(m.group(1))

def extract_from_generator(html: str, headers: dict) -> Optional[str]:
    # 1) Header X-Generator
    gen = headers.get("X-Generator") or headers.get("x-generator")
    if gen:
        m = GEN_HEADER_RE.search(gen)
        if m:
            return normalize_version(m.group(1))
    # 2) Meta generator
    m2 = GEN_META_RE.search(html or "")
    if m2:
        m = GEN_HEADER_RE.search(m2.group(1))
        if m:
            return normalize_version(m.group(1))
    return None

# -------------------- Flujo principal --------------------
def run_enum(base: str, timeout: int = 8, insecure: bool = False, verbose: bool = False) -> Finding:
    notes = []
    version = None
    source = "unknown"
    found_url = ""
    last_status = 0

    # 1) Probar CHANGELOG en múltiples ubicaciones
    for path in CHANGELOG_CANDIDATES:
        url = (base.rstrip("/") + path)
        try:
            status, text, headers = http_get(url, timeout=timeout, verify=(not insecure))
            last_status = status
            if status == 200 and ("drupal" in text.lower()):
                v = extract_from_changelog(text)
                if v:
                    version = v
                    source = "changelog"
                    found_url = url
                    break
        except requests.RequestException as e:
            last_status = 0
            if verbose:
                notes.append(f"ReqError {url}: {e}")

    # 2) Si no hubo CHANGELOG, intentar X-Generator en homepage
    if not version:
        home = base.rstrip("/") + "/"
        try:
            status, text, headers = http_get(home, timeout=timeout, verify=(not insecure))
            last_status = status
            v = extract_from_generator(text, headers)
            if v:
                version = v
                source = "x-generator"
                found_url = home
        except requests.RequestException as e:
            if verbose:
                notes.append(f"HomeError {home}: {e}")

    # 3) Evaluación de vulnerabilidades
    vulns, add_notes = eval_vulns(version) if version else ([], [])
    notes.extend(add_notes)

    return Finding(
        url=found_url or base,
        status=last_status,
        version=version,
        source=source,
        vulnerabilities=vulns,
        notes=notes
    )

def print_report(f: Finding):
    print(f"Objetivo: {f.url}")
    print(f"HTTP status: {f.status or 'N/D'}")
    print(f"Detección: {f.source}")
    print(f"Drupal version: {f.version or 'No detectada'}")
    if f.vulnerabilities:
        print("Riesgos conocidos:")
        for v in f.vulnerabilities:
            print(f" - {v['id']}: {v['name']} (fix: {v['fixed_in']})")
    else:
        print("Riesgos conocidos: ninguno por reglas incluidas (o versión no detectada)")
    if f.notes:
        print("Notas:")
        for n in f.notes:
            print(f" - {n}")

def main():
    ap = argparse.ArgumentParser(description="Enumeración rápida de versión Drupal vía CHANGELOG/X-Generator.")
    ap.add_argument("target", help="Host o URL (ej. 10.10.10.9 o http://10.10.10.9)")
    ap.add_argument("-p", "--port", type=int, default=80, help="Puerto (default: 80)")
    ap.add_argument("-s", "--https", action="store_true", help="Forzar HTTPS")
    ap.add_argument("--insecure", action="store_true", help="No validar TLS (HTTPS)")
    ap.add_argument("-t", "--timeout", type=int, default=8, help="Timeout HTTP (s)")
    ap.add_argument("-o", "--out-json", default=None, help="Ruta para guardar JSON con resultados")
    ap.add_argument("-v", "--verbose", action="store_true", help="Mensajes adicionales")
    args = ap.parse_args()

    base = build_base_url(args.target, https=args.https, port=args.port)
    finding = run_enum(base, timeout=args.timeout, insecure=args.insecure, verbose=args.verbose)
    print_report(finding)

    if args.out_json:
        with open(args.out_json, "w", encoding="utf-8") as fh:
            json.dump(asdict(finding), fh, indent=2, ensure_ascii=False)
        print(f"\n[+] Reporte JSON guardado en: {args.out_json}")

if __name__ == "__main__":
    main()
